# -*- coding: utf-8 -*-
"""
Created on Thu Nov 14 16:59:03 2024
提取所有残基对和分别的残基，可以直接应用到交叠积分的计算
@author: 123
"""

import MDAnalysis as mda
import re
import pandas as pd

def write_gro_file(file_path, atoms, box=None):
    with open(file_path, 'w') as f:
        f.write('Generated by script\n')
        f.write(f'{len(atoms)}\n')
        for atom in atoms:
            residue_number, residue_name, atom_name, atom_number, x, y, z = atom
            f.write(f'{residue_number:5d}{residue_name:5s}{atom_name:5s}{atom_number:5d}{x:8.3f}{y:8.3f}{z:8.3f}\n')
        if box is not None and len(box) > 0:
            f.write(f'{box[0]:10.5f}{box[1]:10.5f}{box[2]:10.5f}\n')

def write_gjf_file(file_path, atoms, charge=0, multiplicity=1):
    with open(file_path, 'w') as f:
        f.write('%NoSave\n')
        f.write('%mem=200GB\n')
        f.write('%nprocshared=32\n')
        f.write('#P wB97XD/def2SVP iop(3/33=1,5/33=3) nosymm\n\n')
        f.write(f'{file_path[:-4]} |DA|\n\n')
        f.write(f'{charge} {multiplicity}\n')
        for atom in atoms:
            element = get_element_symbol(atom[2])
            x, y, z = atom[4], atom[5], atom[6]
            f.write(f'{element:<2} {x:14.8f} {y:14.8f} {z:14.8f}\n')
        f.write('\n\n\n\n\n\n')

def get_element_symbol(atom_name):
    match = re.match(r'^([A-Z][a-z]?)', atom_name)
    if match:
        return match.group(1)
    else:
        return atom_name[0]

def adjust_coordinates_for_pbc(atoms, cell_dimensions):
    coords = atoms.positions.copy()
    box = cell_dimensions[:3]

    for i in range(1, len(coords)):
        for j in range(3):
            while coords[i, j] - coords[i-1, j] > box[j] / 2:
                coords[i, j] -= box[j]
            while coords[i, j] - coords[i-1, j] < -box[j] / 2:
                coords[i, j] += box[j]
    return coords

def process_residue_pair_or_single(tpr_file_path, trr_file_path, resid1, resid2=None):
    u = mda.Universe(tpr_file_path, trr_file_path)
    boxv = u.dimensions

    if resid2 is not None:
        g1 = u.select_atoms(f'resid {resid1} and all')
        g2 = u.select_atoms(f'resid {resid2} and all')
        g1.unwrap()
        g2.unwrap()
        combined = g1 + g2
    else:
        combined = u.select_atoms(f'resid {resid1} and all')
        combined.unwrap()

    # 使用自定义函数处理PBC
    new_coords = adjust_coordinates_for_pbc(combined, boxv)

    # 更新原子坐标
    combined.positions = new_coords

    if resid2 is not None:
        gro_filename = f'{tpr_file_path[:-4]}_{resid1}_{resid2}.gro'
        gjf_filename = f'{tpr_file_path[:-4]}_{resid1}_{resid2}.gjf'
    else:
        gro_filename = f'{tpr_file_path[:-4]}_{resid1}.gro'
        gjf_filename = f'{tpr_file_path[:-4]}_{resid1}.gjf'

    write_gro_file(gro_filename, [(a.resid, a.resname, a.name, a.id, *a.position) for a in combined.atoms], boxv)
    print(f"Saved {gro_filename}")

    write_gjf_file(gjf_filename, [(a.resid, a.resname, a.name, a.id, *a.position) for a in combined.atoms])
    print(f"Converted {gro_filename} to {gjf_filename}")

def main():
    tpr_file_path = 'eC9.tpr'    
    trr_file_path = 'eC9.trr'    
    df = pd.read_excel('Grep.xlsx', header=None)

    # 检查 DataFrame 的列名
    print(df.columns)

    # 处理残基对
    for index, row in df.iterrows():
        resid1, resid2 = row[0], row[1]
        process_residue_pair_or_single(tpr_file_path, trr_file_path, resid1, resid2)

    # 处理单个残基
    for resid in df.values.flatten():
        if resid is not None and resid != '':
            process_residue_pair_or_single(tpr_file_path, trr_file_path, resid)

if __name__ == '__main__':
    main()